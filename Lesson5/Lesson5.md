[//]: <> (Stm32. Переходим на современный C++. Часть 5. Система тактирования.)

# Вступление
На прошлом занятии мы начали рассматривать таймеры, а именно разобрали приемы работы
с базовым таймером. Наименьший период генерации события переполнения, который можно
получить, равен 1/8 мкс (при частоте тактирования таймера 8 Мгц и нулевых значениях
регистров предделителя и автоперезагрузки).
Однако даже в такой конфигурации невозможно реализовать хоть какой-нибудь обработчик прерывания,
который бы выполнялся с этой частотой, поскольку процессор выполняет (и это в лучшем случае)
одну инструкцию за один такт процессора.

Для повышения производительности напрашивается очевидное решение - увеличить частоту,
что равно увеличению количества выполняемых инструкций за единицу времени..

# Система тактирования в Stm32
Сразу рассмотрим рисунок из Reference Manual на линейку Stm32f103xB. У более продвинутых
контроллеров (типа Stm32f4) схема чуть сложнее, но некритично.

![Тактирование](img/1.JPG)

Последовательно рассмотрим составные части этой схемы.

## Тактирование системной шины и периферии
Ядро микропроцессора и его периферийные модули (кроме некоторых) тактируются от соответствующих
шин, главной из которых является **SYSCLK** - системня шина, от которой тактируются остальные шины
и периферийный модули по следующей иерархии:
**SYSCLK**
 - **модуль I2S2**
 - **модуль I2S3**
 - **шина AHB**
    - **модуль SDIO**
    - **модуль FSMC**
    - **модуль системного таймера (System timer)** с делением на 8
    - **шина APB1** с делением на 1, 2, 4, 6, 8, 16
        - **модули таймеров 2-7, 12-14**
    - **шина APB2** с делением на 1, 2, 4, 6, 8, 16
        - **модули таймеров 1, 8-11**
    - **модуль ADC** с деленим на 2, 4, 6, 8

Для других микроконтроллеров эта иерархия может отличаться, но все они
реализуют шинную архитектуру тактирования. В некоторых моделях
существует две шины AHB (AHB1 и AHB2), в некоторых присутствует шина APB3,
а в некоторых наоборот, есть только APB1.

В свою очередь системная шина через мултиплексор может тактироваться от одного
из трех источников:
- **HSI**: сигнал со входа HSI (High-speed internal) - внутреннего высокоскоростного генератора. Для рассматриваемого семейства он имеет частоту 8 Мгц;
- **PLLCLK**: сигнал со входа умножителя частоты с программируемым коэффициентом умножения и деления;
- **HSE**: сигнал со входа HSE (High-speed external) - внешнего 
высокоскоростного генератора. Данный источник реализован двумя входами **OSC_IN** и **OSC_OUT**, к которым должен быть подключен резонатор с частотой 4-16 Мгц.

Если с тактированием системной шины от HSI и HSE все понятно (частота 
системной шины равна частоте источника), то PLL стоит описать более подробно,
так как он программируемый и, как правило, в большинстве случаев именно он
является источником тактового сигнала, поскольку позволяет добиться максимально
возможной частоты работы микроконтроллера.

### Настройка PLL
В более простых контроллерах, к которым можно отнести и Stm32f103, на вход PLL
через мультиплексор (битом `PLLSRC`) можно подать либо сигнал с внутреннего высокоскоростного 
источника (HSI) с делителем, равным 2, либо сигнал с внешнего высокоскоростного источника (HSE), который, в свою  очередь, также через мультиплексор (битом `PLLXTPRE`) может иметь делитель 1 или 2.

На выходе PLL может быть получен сигнал с частотой, равной частоте входного сигнала PLL, 
умноженной на 2, 3, 4, ..., 16, что задается битами `PLLMUL`.

Таким образом, для популярной платы **Blue pill** с контроллером Stm32f103c8t6 максимальная
частота 72 Мгц может быть получена, например, умножением сигнала HSE (который, как правило,
имеет частоту 8 Мгц) на 9.

Необходимо учитывать, что для некоторых шин и модулей микроконтроллера существует ограничение
сверху на частоту тактового сигнала. Например, для Stm32f103 гина APB1 не может иметь частоту
более 36 Мгц, соответственно, при настройке системной шины на наивысшую скорость 72 Мгц
для корректной работы необходимо установить делитель шины APB1 в значение 2.

## Тактирование часов реального времени (RTC)

Поверхностно рассмотрим систему тактирования **часов реального времени** (Real-time clock, RTC),
ее схема приведена на рисунке.

![Тактирование RTC](img/2.JPG)

**RTCCLK** - это линия, непосредственно тактирующая модуль часов реального времени.
Как можно заметить, данная линия является выходом мультиплексора с тремя входами,
который управляется битами `RTCSEL[1:0]`, позволяя выбрать один из следующих вариантов источника
тактового сигнала:
- **HSE/128**: сигнал со входа HSE с делением на 128;
- **LSE**: сигнал со входа LSE (Low-speed external). Данный источник тактового сигнала реализован двумя входами **OSC32_IN** и **OSC32_OUT**, к которым должен быть подключен резонатор с частотой 32.768 Гц;
- **LSI**: сигнал со входа LSI (Low-speed internal) - внутренний низкоскоростной источник тактового сигнала.
    Сигнал с него также тактирует независимый сторожевой таймер (Independent Watchdog, IWDG).

Более подробно потребители этих тактовых сигналов (а именно модули часов реального времени и сторожевого таймера)
будут рассмотрены далее. Сейчас же стоит отметить, что рекомендованным источником для RTC является внешний резонатор (LSI).

## Выход MCO

![Тактирование MCO](img/3.JPG)

В сложных устройствах может потребоваться синхронизация между различными элементами, которой можно 
добиться путем получения тактирующего сигнала от микроконтроллера. В Stm32 эту функцию выполняет
выход **MCO** (Main clock output), который через мультиплексор позволяет выбрать один из следующих сигналов:
- **PLLCLK/2**: выход PLL с делением на 2;
- **HSI**:  сигнал с внутреннего высокоскоростного генератора;
- **HSE**:  сигнал с внешнего высокоскоростного генератора;
- **SYSCLK**: сигнал с системной шины.

## Библиотека Zhele и настройка тактирования
Библиотека Zhele содержит соответствующие типы данных (классы) для каждого 
элемента системы тактирования (источников сигнала, умножителя частоты, шин), 
позволяя тонко настраивать систему тактирования.

[//]: <> (Вставить описания классов источников тактирования и шин)

Модифицируем пример с прошлого занятия, предварительно настроив
системную шину на частоту 72 Мгц (путем умножения сигнала с HSE на 9).
Для того, чтобы светодиод по-прежнему изменял состояние раз в секунду, необходимо изменить
значения предделителя и регистра перезагрузки таймера. Например, установить предделитель в значение _12000_, а регистр перезагрузки в _6000_.

```с++
#include <clock.h>
#include <iopins.h>
#include <timer.h>

using namespace Zhele::Clock;
using namespace Zhele::IO;
using namespace Zhele::Timers;

using Led = Pc13Inv;
using LedTimer = Timer2;

int main()
{
    // Настройка тактирования
    // Выбираем HSE как источник для PLL
    PllClock::SelectClockSource(PllClock::External);
    // Устанавливаем коэффициент умножения
	PllClock::SetMultiplier(9);
	// Устанавливаем делитель шины APB1 (ее макс.частота равно 36 МГц)
	Apb1Clock::SetPrescaler(Apb1Clock::Div2);
	// Выбираем PLL как источник для тактирования системной шины
	SysClock::SelectClockSource(SysClock::Pll);

    // Настройка светодиода
    Led::Port::Enable();
    Led::SetConfiguration(Led::Configuration::Out);
    Led::SetDriverType(Led::DriverType::PushPull);
    Led::Clear();

    LedTimer::Enable();
    LedTimer::SetPrescaler(11999); // Предделитель = 12000
    LedTimer::SetPeriod(3999); // Период = 4000. Итого период таймера = 72000000/12000/4000 = 1.
    LedTimer::EnableInterrupt();
    LedTimer::Start();

    for (;;)
    {
    }
}

extern "C"
{
    void TIM2_IRQHandler()
    {
        // Изменение состояния светодиода
        Led::Toggle();
        // Сброс флага прерывания
        LedTimer::ClearInterruptFlag();
    }
}
```